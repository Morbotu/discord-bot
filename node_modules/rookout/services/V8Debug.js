"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.V8Debug = void 0;

var _logger = require("../logger");

var _IgnoredNodeModules = require("./IgnoredNodeModules");

var _exceptions = require("../exceptions");

var _V8FrameNamespace = _interopRequireDefault(require("../processor/namespaces/V8FrameNamespace"));

var _V8StackNamespace = _interopRequireDefault(require("../processor/namespaces/V8StackNamespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const vm = require('vm');

const debug = vm.runInDebugContext('Debug');

class V8Debug {
  constructor(userLine, scriptLoaded, getScript) {
    const self = this;
    this.getScriptCallback = getScript;
    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
    debug.setListener((event, execState, eventData) => {
      try {
        try {
          if (debug.DebugEvent.Break === event) {
            const pos = this.breakpointsToPositions[eventData.break_points_hit_[0].script_break_point_.number_];
            userLine(pos, new _V8FrameNamespace.default(self, execState.frame(0)), new _V8StackNamespace.default(self, execState));
          } else if (debug.DebugEvent.AfterCompile === event) {
            const name = eventData.script_.name();

            if (name && !(0, _IgnoredNodeModules.isBlackListedModule)(name)) {
              scriptLoaded(eventData.script_.id(), name, eventData.script_.source());
            }
          }
        } catch (e) {
          _logger.logger.exception("Error while processing breakpoint", e);
        }
      } catch (e) {}
    });
  }

  setBreak(pos) {
    // NOTE - we do not expect to have any pre-processing logic required here because the script has already been resolved
    let breakpoint = debug.setScriptBreakPointByName(pos.filename, pos.lineno - 1, pos.column + 1);

    if (null == breakpoint) {
      throw new _exceptions.RookSetBreakpointFailed();
    }

    this.positionsToBreakpoints[pos.toKey()] = breakpoint;
    this.breakpointsToPositions[breakpoint] = pos;
  }

  clearBreak(pos) {
    // If we have an object, hash it
    if (pos.toKey) {
      pos = pos.toKey();
    }

    const breakpoint = this.positionsToBreakpoints[pos];

    if (undefined === breakpoint) {
      return;
    }

    delete this.positionsToBreakpoints[pos];
    delete this.breakpointsToPositions[breakpoint];
    debug.clearBreakPoint(breakpoint);
  }

  clearAllBreaks() {
    let positions = Object.keys(this.positionsToBreakpoints);

    for (let i = 0; i < positions.length; ++i) {
      this.clearBreak(positions[i]);
    }

    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
  }

  getScript(scriptId) {
    return this.getScriptCallback(scriptId);
  }

  close() {
    this.clearAllBreaks();
    debug.setListener(null);
  }

  scripts() {
    let result = [];

    for (let script of debug.scripts()) {
      if (null != script.name && !(0, _IgnoredNodeModules.isBlackListedModule)(script.name)) {
        result.push({
          scriptId: script.id,
          filename: script.name,
          source: script.source
        });
      }
    }

    return result;
  }

}

exports.V8Debug = V8Debug;
//# sourceMappingURL=V8Debug.js.map