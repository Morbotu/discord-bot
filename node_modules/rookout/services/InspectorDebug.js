"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InspectorDebug = void 0;

var _logger = require("../logger");

var _exceptions = require("../exceptions");

var _IgnoredNodeModules = require("./IgnoredNodeModules");

var _InspectorFrameNamespace = _interopRequireDefault(require("../processor/namespaces/InspectorFrameNamespace"));

var _InspectorStackNamespace = _interopRequireDefault(require("../processor/namespaces/InspectorStackNamespace"));

var _DebuggerBackchannel = _interopRequireDefault(require("./DebuggerBackchannel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inspector = require('inspector');

const url = require('url');

const rook = require("../index");

global.__rookout_backchannel = new _DebuggerBackchannel.default();

class InspectorDebug {
  constructor(userLine, scriptLoaded, getScript) {
    const self = this;
    this.getScriptCallback = getScript;
    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
    this.loadedScriptsCount = 0;
    this.maxLoadedScripts = parseInt(process.env.ROOKOUT_MAX_SCRIPTS) || 20000;
    this.session = new inspector.Session();

    try {
      this.session.connect();
    } catch (e) {
      throw new _exceptions.RookInspectorConnectFailed(e);
    }

    this.session.on('Debugger.scriptParsed', script => {
      if (self.session === null) {
        return;
      }

      try {
        self.loadedScriptsCount++;

        if (self.loadedScriptsCount > self.maxLoadedScripts && rook.savedOptions !== null) {
          _logger.logger.warn("An unreasonable number of scripts loaded - restarting");

          self.loadedScriptsCount = 0;
          rook.stop();
          rook.start();
          return;
        }

        if (false === script.params.isModule) {
          let scriptURL = script.params.url; // URLs instead of paths started in 10.12 which also introduced this
          // url.fileURLToPath. We assume we will not receive URLs before 10.12

          if (scriptURL.startsWith("file:") && url.fileURLToPath !== undefined) {
            scriptURL = url.fileURLToPath(scriptURL);
          }

          if ((0, _IgnoredNodeModules.isBlackListedModule)(scriptURL)) {
            return;
          }

          self.post('Debugger.getScriptSource', {
            scriptId: script.params.scriptId
          }, (err, scriptSource) => {
            if (err) {
              _logger.logger.exception("Failed to get script source", err);

              return;
            }

            try {
              scriptLoaded(script.params.scriptId, scriptURL, scriptSource.scriptSource);
            } catch (error) {
              _logger.logger.exception("Exception when processing script source callback", error);
            }
          });
        }
      } catch (error) {
        _logger.logger.exception("Exception when processing script parse callback", error);
      }
    });
    this.session.on('Debugger.paused', message => {
      if (self.session === null) {
        return;
      }

      try {
        const pos = self.breakpointsToPositions[message.params.hitBreakpoints[0]];
        userLine(pos, new _InspectorFrameNamespace.default(self, message.params.callFrames[0]), new _InspectorStackNamespace.default(self, message.params.callFrames));
      } catch (error) {
        _logger.logger.exception(error);
      } finally {
        this.post("Debugger.resume");
      }
    });
    this.session.on('error', error => {
      try {
        _logger.logger.exception('InspectorDebugger error', error);
      } catch (e) {}
    });
    this.post('Debugger.enable');
    this.post('Debugger.setBreakpointsActive', {
      active: true
    });
  }

  setBreak(pos) {
    let result = {};
    let scriptURL = pos.filename;

    if (url.pathToFileURL !== undefined) {
      scriptURL = url.pathToFileURL(scriptURL);
    }

    this.post('Debugger.setBreakpointByUrl', {
      url: scriptURL,
      lineNumber: pos.lineno - 1,
      columnNumber: pos.column + 1
    }, (error, response) => {
      result.error = error;
      result.response = response;
    });

    if (null != result.error) {
      throw new _exceptions.RookInspectorSetBreakpointFailed(result.error);
    }

    this.positionsToBreakpoints[pos.toKey()] = result.response.breakpointId;
    this.breakpointsToPositions[result.response.breakpointId] = pos;
  }

  clearBreak(pos) {
    // If we have an object, hash it
    if (pos.toKey) {
      pos = pos.toKey();
    }

    const breakpointId = this.positionsToBreakpoints[pos];

    if (undefined === breakpointId) {
      return;
    }

    delete this.positionsToBreakpoints[pos];
    delete this.breakpointsToPositions[breakpointId];
    let result = {};
    this.post('Debugger.removeBreakpoint', {
      breakpointId: breakpointId
    }, error => {
      result.error = error;
    });

    if (null != result.error) {
      _logger.logger.error("Failed to remove breakpoint", result.error);
    }
  }

  clearAllBreaks() {
    let positions = Object.keys(this.positionsToBreakpoints);

    for (let i = 0; i < positions.length; ++i) {
      this.clearBreak(positions[i]);
    }

    this.positionsToBreakpoints = {};
    this.breakpointsToPositions = {};
  }

  post(message_id, params, cb) {
    if (this.session === null) {
      if (cb !== undefined) {
        cb(new Error("No debug session"), null);
      }

      return;
    }

    this.session.post(message_id, params, cb);
  }

  getProperties(object, ownProperties = true) {
    let result = {};
    this.post('Runtime.getProperties', {
      objectId: object.objectId,
      ownProperties: ownProperties
    }, (error, value) => {
      if (error) {
        result.error = error;
      } else {
        result.value = value.result;
      }
    });

    if (result.error) {
      throw new RookInspectorFailedToGetObject(object);
    }

    return result.value;
  }

  getScript(scriptId) {
    return this.getScriptCallback(scriptId);
  }

  close() {
    this.clearAllBreaks();
    this.post('Debugger.setBreakpointsActive', {
      active: false
    });
    this.post('Debugger.disable');
    this.session.disconnect();
    this.session = null;
  }

  scripts() {
    return [];
  }

}

exports.InspectorDebug = InspectorDebug;
//# sourceMappingURL=InspectorDebug.js.map