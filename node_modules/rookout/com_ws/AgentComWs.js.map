{"version":3,"sources":["../../../src/com_ws/AgentComWs.js"],"names":["config","require","messages_pb","envelope_pb","timestamp_pb","any_pb","MessageCallback","constructor","cb","persistent","AgentComWs","id","agentHost","agentPort","proxy","token","labels","tags","host","includes","port","_lastSuccessfulConnection","_callbacks","_connected","_currentBackoff","AgentComConfiguration","BACK_OFF","_retry","_stopping","_connection","_reconnectPromise","_previousSendPromise","Promise","resolve","_pendingMessages","_lambdaKeepAliveInterval","setInterval","unref","_connecting","_lastSuccessfulPing","_connectionEstablishedCallbacks","_pingTimeout","close","terminate","onConnectionEstablished","push","waitForReconnect","ensureConnected","timeout","connectedPromise","Date","now","WS_PING_TIMEOUT","clearTimeout","race","timeoutRejecter","flushMessages","then","pendingMessage","shift","currentSendPromise","undefined","send","catch","getTypeName","command","k","Object","keys","proto","com","rookout","ToolException","add","message","envelope","wrapInEnvelope","addEnvelope","isConnected","length","MAX_QUEUED_MESSAGES","on","message_name","callback","_registerCallback","once","awaitMessage","messageName","hasOwnProperty","reject","setTimeout","RookCommunicationException","_connectToAgentNoTimeout","startNewConnection","registerAgent","callbacks","err","statusCode","RookInvalidToken","RookError","connectToAgent","connectAndRegister","info","information","collect","agent_id","m","NewAgentMessage","setAgentInfo","pack_agent_info","gotInitialAugsCommand","logger","notifyLambdaInactive","notifyLambdaActive","ref","Envelope","time","date","Timestamp","fromDate","setTimestamp","any","Any","pack","serializeBinary","setMsg","previousSendPromise","sendMsg","rookErr","binary","RookSendFailedError","RookNotConnectedError","handleIncomingMessage","msg","deserializeBinary","typeName","getMsg","partialTypeName","slice","type","getValue","remaining_callbacks","forEach","debug","buildProxy","startsWith","ws","WebSocket","headers","VersionConfiguration","VERSION","COMMIT","agent","error","e","CONNECT_TIMEOUT","pingInterval","ping","PING_INTERVAL","gotError","reconnect","closed","clearInterval","RESET_BACKOFF_TIMEOUT","Math","min","MAX_SLEEP","reason","r","heartbeat","PING_TIMEOUT","_socket","req","resp"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nimport WebSocket from 'ws';\r\nimport HttpsProxyAgent from 'https-proxy-agent';\r\n\r\nimport {logger} from '../logger';\r\n\r\nimport * as information from \"./information\";\r\nimport {\r\n    RookCommunicationException,\r\n    RookInvalidToken,\r\n    ToolException,\r\n    RookSendFailedError,\r\n    RookNotConnectedError\r\n} from '../exceptions'\r\nimport RookError from \"../processor/RookError\";\r\n\r\nconst config = require(\"../config\");\r\nconst messages_pb = require(\"../protobuf/messages_pb\");\r\nconst envelope_pb = require(\"../protobuf/envelope_pb\");\r\nconst timestamp_pb = require(\"google-protobuf/google/protobuf/timestamp_pb\");\r\nconst any_pb = require(\"google-protobuf/google/protobuf/any_pb\");\r\n\r\nclass MessageCallback {\r\n    constructor(cb, persistent) {\r\n        this.cb = cb;\r\n        this.persistent = persistent;\r\n    }\r\n}\r\n\r\nexport default class AgentComWs {\r\n\r\n    constructor(id, agentHost, agentPort, proxy=null, token=null, labels=null, tags=null) {\r\n        this.id = id;\r\n        this.host = agentHost.includes('://') ? agentHost : 'ws://' + agentHost;\r\n        this.port = agentPort;\r\n        this.proxy = proxy;\r\n        this.labels = labels || {};\r\n        this.tags = tags || [];\r\n        this.token = token || '';\r\n        this._lastSuccessfulConnection = 0;\r\n\r\n        this._callbacks = {};\r\n        this._connected = false;\r\n        this._currentBackoff = config.AgentComConfiguration.BACK_OFF;\r\n        this._retry = 0;\r\n        this._stopping = false;\r\n        this._connection = null;\r\n        this._reconnectPromise = null;\r\n        this._previousSendPromise = Promise.resolve();\r\n        this._pendingMessages = [];\r\n        // Used to keep lambdas alive before we're finished.\r\n        // Normally you would use the socket, but we might want to keep running when the socket doesn't exist\r\n        // (e.g. after disconnection followed by a flush at the end of lambda execution)\r\n        this._lambdaKeepAliveInterval = setInterval(() => { if (1) {}}, 60000).unref();\r\n        this._connecting = false;\r\n        this._lastSuccessfulPing = 0;\r\n        this._connectionEstablishedCallbacks = []; // Used by waitForReconnect - don't use with anything else\r\n        this._pingTimeout = null;\r\n    }\r\n\r\n    close() {\r\n        this._stopping = true;\r\n\r\n        if (this._connection) {\r\n            this._connection.terminate();\r\n            this._connection = null;\r\n        }\r\n\r\n        this._connected = false;\r\n    }\r\n\r\n    onConnectionEstablished(cb) {\r\n        this._connectionEstablishedCallbacks.push(() => cb());\r\n    }\r\n\r\n    waitForReconnect() {\r\n        if (this._reconnectPromise) {\r\n            return this._reconnectPromise;\r\n        }\r\n        this._reconnectPromise = new Promise(resolve => {\r\n            this.onConnectionEstablished(() => {\r\n                this._reconnectPromise = null;\r\n                resolve();\r\n            });\r\n        });\r\n\r\n        return this._reconnectPromise;\r\n    }\r\n\r\n    ensureConnected(timeout=30000) {\r\n        let connectedPromise = Promise.resolve();\r\n\r\n        if (this._connecting) {\r\n            connectedPromise = this.waitForReconnect();\r\n        } else {\r\n            if (Date.now() - this._lastSuccessfulPing > config.AgentComConfiguration.WS_PING_TIMEOUT * 1000) {\r\n                if (this._connection) {\r\n                    // The timeout could run after we terminate the connection, and terminate our reconnect.\r\n                    if (this._pingTimeout) {\r\n                        clearTimeout(this._pingTimeout);\r\n                        this._pingTimeout = null;\r\n                    }\r\n                    this._connection.terminate();\r\n                    this._connection = null;\r\n                }\r\n\r\n                connectedPromise = this.waitForReconnect();\r\n            }\r\n        }\r\n\r\n        return Promise.race([connectedPromise, this.timeoutRejecter(timeout)]);\r\n    }\r\n\r\n    flushMessages() {\r\n        // Returns a promise that is resolved or rejected once all messages up to this point have been\r\n        // sent or failed to send.\r\n\r\n        // Upon successful connection, enqueue all pending messages for sending.\r\n        return new Promise((resolve) => {\r\n            this.ensureConnected().then(() => {\r\n                let pendingMessage = this._pendingMessages.shift();\r\n                // This variable is necessary to get the last return value from this.send -\r\n                // just using this._previousSendPromise would put it into the closure,\r\n                // and we'll just use whatever value was there at the time\r\n                // the Promise was created.\r\n                let currentSendPromise = this._previousSendPromise;\r\n                while (pendingMessage !== undefined) {\r\n                    currentSendPromise = this.send(pendingMessage);\r\n                    pendingMessage = this._pendingMessages.shift();\r\n                }\r\n                currentSendPromise.then(() => {\r\n                    resolve();\r\n                });\r\n            }).catch(\r\n                () => {}\r\n            );\r\n        });\r\n    }\r\n\r\n    static getTypeName(command) {\r\n        for (let k of Object.keys(proto.com.rookout)) {\r\n            if (proto.com.rookout[k] === command.constructor) {\r\n                return \"com.rookout.\" + k;\r\n            }\r\n        }\r\n\r\n        throw new ToolException();\r\n    }\r\n\r\n\r\n    // DON'T LOG HERE - THIS FUNCTION IS INDIRECTLY CALLED FROM WITHIN THE LOGGER\r\n    // LOGGING HERE LEADS TO INFINITE RECURSION\r\n    add(message) {\r\n        let envelope = AgentComWs.wrapInEnvelope(message);\r\n        this.addEnvelope(envelope)\r\n    }\r\n\r\n    // DON'T LOG HERE - THIS FUNCTION IS INDIRECTLY CALLED FROM WITHIN THE LOGGER\r\n    // LOGGING HERE LEADS TO INFINITE RECURSION\r\n    addEnvelope(envelope) {\r\n        if (!this.isConnected()) {\r\n            if (this._pendingMessages.length < config.AgentComConfiguration.MAX_QUEUED_MESSAGES) {\r\n                this._pendingMessages.push(envelope);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.ensureConnected().then(() => this.send(envelope));\r\n    }\r\n\r\n    on(message_name, callback) {\r\n        this._registerCallback(message_name, new MessageCallback(callback, true))\r\n    }\r\n\r\n    once(message_name, callback) {\r\n        this._registerCallback(message_name, new MessageCallback(callback, false))\r\n    }\r\n\r\n    awaitMessage(message_name) {\r\n        return new Promise(resolve => {\r\n            this.once(message_name, resolve);\r\n        })\r\n    }\r\n\r\n    _registerCallback(messageName, callback) {\r\n        if (!(this._callbacks.hasOwnProperty(messageName))) {\r\n            this._callbacks[messageName] = [];\r\n        }\r\n        this._callbacks[messageName].push(callback);\r\n    }\r\n\r\n    timeoutRejecter(timeout) {\r\n        return new Promise((resolve, reject) => {\r\n            setTimeout(() => {\r\n                if (!this._connection) {\r\n                    reject(new RookCommunicationException());\r\n                }\r\n                resolve();\r\n            }, timeout).unref();\r\n        })\r\n    }\r\n\r\n    isConnected() {\r\n        return this._connected;\r\n    }\r\n\r\n    async _connectToAgentNoTimeout() {\r\n        try {\r\n            await this.startNewConnection();\r\n            await this.registerAgent();\r\n\r\n            const callbacks = this._connectionEstablishedCallbacks;\r\n            this._connectionEstablishedCallbacks = [];\r\n            for (const cb of callbacks) {\r\n                cb();\r\n            }\r\n            this.flushMessages();\r\n\r\n            return true;\r\n        } catch (err) {\r\n            if (err.hasOwnProperty(\"statusCode\")) {\r\n                if (err.statusCode === 403) {\r\n                    throw new RookInvalidToken(this.token);\r\n                }\r\n                throw new RookError(err, `Got unexpected response from server with status code: ${err.statusCode}`);\r\n            } else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n\r\n    async connectToAgent(timeout) {\r\n        let connectAndRegister = this._connectToAgentNoTimeout();\r\n\r\n        if (!timeout) {\r\n            return connectAndRegister;\r\n        }\r\n\r\n        return Promise.race([connectAndRegister, this.timeoutRejecter(timeout)]);\r\n    }\r\n\r\n    async registerAgent() {\r\n        let info = await information.collect();\r\n        info.agent_id = this.id;\r\n        info.labels = this.labels;\r\n        if (this.tags !== undefined) {\r\n            info.tags = this.tags;\r\n        }\r\n\r\n        let m = new messages_pb.NewAgentMessage();\r\n        m.setAgentInfo(information.pack_agent_info(info));\r\n\r\n        let gotInitialAugsCommand = this.awaitMessage(\"InitialAugsCommand\");\r\n\r\n        await this.send(AgentComWs.wrapInEnvelope(m));\r\n        this._lastSuccessfulConnection = Date.now();\r\n        await gotInitialAugsCommand;\r\n        this._connected = true;\r\n\r\n        logger.info(\"Finished initialization\");\r\n    }\r\n\r\n    notifyLambdaInactive() {\r\n        this._lambdaKeepAliveInterval.unref();\r\n    }\r\n\r\n    notifyLambdaActive() {\r\n        this._lambdaKeepAliveInterval.ref();\r\n    }\r\n\r\n    static wrapInEnvelope(message) {\r\n        let envelope = new envelope_pb.Envelope();\r\n        const time = new Date();\r\n        let date = new timestamp_pb.Timestamp();\r\n        date.fromDate(time);\r\n        envelope.setTimestamp(date);\r\n        let any = new any_pb.Any();\r\n        any.pack(message.serializeBinary(), AgentComWs.getTypeName(message));\r\n        envelope.setMsg(any);\r\n        return envelope;\r\n    }\r\n\r\n    // DON'T LOG HERE - THIS FUNCTION IS INDIRECTLY CALLED FROM WITHIN THE LOGGER\r\n    // LOGGING HERE LEADS TO INFINITE RECURSION\r\n    send(message) {\r\n        // Promise chaining is used here to simulate queue-like behavior (messages are sent in the order they are\r\n        //                                                                passed to send)\r\n        let previousSendPromise = this._previousSendPromise;\r\n        let sendMsg = (resolve, reject) => {\r\n            let rookErr = null;\r\n            if (this._connection) {\r\n                this._connection.send(message.serializeBinary(), {binary: true}, (err) => {\r\n                    if (err) {\r\n                        rookErr = new RookSendFailedError();\r\n                    } else {\r\n                        resolve(); // send was successful\r\n                    }\r\n                })\r\n            } else {\r\n                rookErr = new RookNotConnectedError();\r\n            }\r\n            if (rookErr !== null) {\r\n                this.addEnvelope(message);\r\n                resolve();\r\n            }\r\n        };\r\n        this._previousSendPromise = new Promise((resolve, reject) => {\r\n            previousSendPromise.then(() => sendMsg(resolve, reject))\r\n                .catch(() => {sendMsg(resolve, reject)}).catch(\r\n                    // Intentionally empty catch block\r\n                    () => {});\r\n        });\r\n\r\n        return this._previousSendPromise;\r\n    }\r\n\r\n    handleIncomingMessage(msg) {\r\n        let envelope = envelope_pb.Envelope.deserializeBinary(msg);\r\n        let typeName = envelope.getMsg().getTypeName();\r\n\r\n\r\n        const partialTypeName = typeName.slice(\"com.rookout.\".length);\r\n        let type = proto.com.rookout[partialTypeName];\r\n        let message = type.deserializeBinary(envelope.getMsg().getValue());\r\n\r\n        const callbacks = this._callbacks[partialTypeName];\r\n\r\n        if (callbacks !== undefined) {\r\n            let remaining_callbacks = [];\r\n\r\n            callbacks.forEach((callback) => {\r\n               try {\r\n                   callback.cb(message)\r\n               } catch (err) {\r\n                   logger.debug(`Silenced error from callback: ${err}`)\r\n               } finally {\r\n                   if (callback.persistent) {\r\n                       remaining_callbacks.push(callback)\r\n                   }\r\n               }\r\n\r\n            });\r\n\r\n            this._callbacks[partialTypeName] = remaining_callbacks\r\n        }\r\n    }\r\n\r\n    buildProxy() {\r\n        if (this.proxy === null) {\r\n            return false;\r\n        }\r\n\r\n        logger.debug(\"Connecting via proxy: %s\", this.proxy);\r\n\r\n        if (this.proxy.startsWith(\"http\")) {\r\n            return HttpsProxyAgent(this.proxy);\r\n        } else {\r\n            return HttpsProxyAgent(\"http://\" + this.proxy);\r\n        }\r\n    }\r\n\r\n    startNewConnection() {\r\n        return new Promise((resolve, reject) => {\r\n            let proxy = this.buildProxy();\r\n\r\n            try {\r\n                // Initiate the connection.\r\n                let ws = new WebSocket(`${this.host}:${this.port}/v1`,  {\r\n                    headers:  {\r\n                        \"User-Agent\": `RookoutAgent/${config.VersionConfiguration.VERSION}+${config.VersionConfiguration.COMMIT}`,\r\n                        \"X-Rookout-Token\": this.token\r\n                    },\r\n                    agent: proxy\r\n                });\r\n\r\n                this._connection = ws;\r\n                this._connecting = true;\r\n                this._pingTimeout = setTimeout(() => {\r\n                    logger.error(\"WS connect timeout, closing connection\");\r\n                    try {\r\n                        if (this._connection) {\r\n                            this._connection.terminate();\r\n                            this._connection = null;\r\n                        }\r\n                    } catch (e) {}\r\n                }, config.AgentComConfiguration.CONNECT_TIMEOUT * 1000);\r\n                this._pingTimeout.unref();\r\n\r\n                // Send pings every WS_PING_INTERVAL.\r\n                let pingInterval = setInterval(() => {\r\n                    ws.ping(() => {});\r\n                }, config.AgentComConfiguration.PING_INTERVAL * 1000);\r\n                pingInterval.unref();\r\n                this._connection = ws;\r\n\r\n\r\n                let gotError = false;\r\n\r\n\r\n                let reconnect = (error, closed) => {\r\n                    if (this._stopping) {\r\n                        return;\r\n                    }\r\n\r\n                    // already reconnecting\r\n                    if (this._connecting) {\r\n                        return;\r\n                    }\r\n\r\n                    this._connecting = true;\r\n\r\n                    clearTimeout(this._pingTimeout);\r\n                    clearInterval(pingInterval);\r\n\r\n                    if (this._connected && Date.now() >= this._lastSuccessfulConnection + config.AgentComConfiguration.RESET_BACKOFF_TIMEOUT) {\r\n                        this._retry = 0;\r\n                        this._currentBackoff = config.AgentComConfiguration.BACK_OFF;\r\n                    }\r\n\r\n                    this._connected = false;\r\n                    this._previousSendPromise = Promise.resolve();\r\n\r\n                    this._retry += 1;\r\n                    this._currentBackoff = Math.min(this._currentBackoff * 2, config.AgentComConfiguration.MAX_SLEEP);\r\n                    let reason = \"N/A\";\r\n\r\n                    if (closed) {\r\n                        reason = \"Connection closed\";\r\n                    } else if (error) {\r\n                        reason = error;\r\n                    }\r\n\r\n                    // Report the error and start a timer for reconnection.\r\n                    logger.info(\"Connection failed; reason = %s, retry = #%d, waiting %fs\", reason, this._retry, this._currentBackoff);\r\n\r\n                    setTimeout(() => this.connectToAgent().then((r) => resolve(r)).catch((e) => reject(e)),\r\n                        this._currentBackoff * 1000).unref()\r\n                };\r\n\r\n                // Heartbeat runs on every pong, as well as once on a new connection.\r\n                let heartbeat = () => {\r\n                    this._lastSuccessfulPing = Date.now();\r\n                    clearTimeout(this._pingTimeout);\r\n                    this._pingTimeout = setTimeout(() => {\r\n                        try {\r\n                            if (this._connection) {\r\n                                this._connection.terminate();\r\n                                this._connection = null;\r\n                            }\r\n                        } catch (e) {}\r\n                    }, config.AgentComConfiguration.PING_TIMEOUT * 1000);\r\n                    this._pingTimeout.unref();\r\n                };\r\n\r\n                ws.on(\"open\", () => {\r\n                    logger.debug(\"Connection established\");\r\n                    heartbeat();\r\n                    this._connecting = false;\r\n                    // The socket does not exist before this point except internally - we can't access it.\r\n                    // Upon a connection timeout (currently 2 seconds), the socket will be terminated.\r\n                    ws._socket.unref();\r\n\r\n                    resolve(ws);\r\n                });\r\n                ws.on(\"pong\", () => heartbeat());\r\n                ws.on(\"close\", () => {\r\n                    // in the case of an error, this callback is called as well as on(\"error\")\r\n                    if (!gotError) {\r\n                        this._connecting = false;\r\n                        reconnect(null, true);\r\n                    }\r\n                    // intentionally no reject here - the error is handled by reconnect\r\n                });\r\n\r\n                ws.on(\"message\", msg => this.handleIncomingMessage(msg)); // Connection errors (e.g. abrupt termination)\r\n\r\n                // Connection errors (e.g. abrupt termination)\r\n                ws.on(\"error\", err => {\r\n                    this._connecting = false;\r\n                    gotError = true;\r\n                    reconnect(err);\r\n                    // intentionally no reject here - the error is handled by reconnect\r\n                });\r\n\r\n                // Unexpected HTTP responses\r\n                ws.on(\"unexpected-response\", (req, resp) => {\r\n                    reconnect(resp.statusCode);\r\n                    reject({\r\n                        statusCode: resp.statusCode\r\n                    });\r\n                });\r\n            } catch (err) {\r\n                reject(err);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n"],"file":"AgentComWs.js"}