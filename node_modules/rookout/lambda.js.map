{"version":3,"sources":["../../src/lambda.js"],"names":["RookoutLambdaWrapper","constructor","rookout","originalThis","originalFunction","originalEvent","originalContext","originalCallback","notifyLambdaActive","callbackCalled","originalFunctionReturnedPromise","logger","require","context","Object","assign","done","error","result","flush","fail","succeed","callback","err","boundCallback","bind","notifyLambdaInactive","invoke","call","self","undefined","then","Promise","resolve","reject","value","debug","catch","flushPromise","race","timeoutResolver","timeout","setTimeout","unref","invokeAndChain","wrapper","invoke_result","exports","wrap","options","process","env","LAMBDA_TASK_ROOT","rook","startRook","startAttempted","log_file","lambda_safe_start","start","event"],"mappings":"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","sourcesContent":["'use strict';\n\nclass RookoutLambdaWrapper {\n    constructor(rookout, originalThis, originalFunction, originalEvent, originalContext, originalCallback) {\n        this.rookout = rookout;\n        this.rookout.notifyLambdaActive(originalContext);\n        this.originalThis = originalThis;\n        this.originalFunction = originalFunction;\n        this.originalEvent = originalEvent;\n        this.originalContext = originalContext;\n        this.originalCallback = originalCallback;\n        this.callbackCalled = false;\n        this.originalFunctionReturnedPromise = false;\n\n        // The constructor is called _after_ `rookout.start`, but imported _before_ `rookout.start` --\n        // importing the logger in this file means it'll be initialized too early.\n        this.logger = require(\"./logger\").logger;\n\n        this.context = Object.assign({}, this.originalContext, {\n            done: (error, result) => {\n                this.flush(() => {\n                    this.originalContext.done(error, result);\n                });\n            },\n\n            fail: (error) => {\n                this.flush(() => {\n                    this.originalContext.fail(error);\n                });\n            },\n\n            succeed: (result) => {\n                this.flush(() => {\n                    this.originalContext.succeed(result);\n                });\n            }\n        });\n    }\n\n    callback(err, result) {\n        this.boundCallback = this.originalCallback.bind(this.originalThis, err, result);\n        this.callbackCalled = true;\n        this.flush(() => {\n            if (!this.originalFunctionReturnedPromise) {\n                this.boundCallback();\n            }\n            this.rookout.notifyLambdaInactive(this.context);\n        });\n    }\n\n    invoke() {\n        let result = this.originalFunction.call(this.originalThis, this.originalEvent, this.context,\n            this.callback.bind(this));\n        const self = this;\n\n        if (result !== undefined && result.then !== undefined) {\n            this.originalFunctionReturnedPromise = true;\n\n            return new Promise((resolve, reject) => {\n                result.then((value) => {\n                    self.flush(() => {\n                        // The user might have returned a Promise/used an async function *and* called the callback.\n                        if (this.callbackCalled) {\n                            self.logger.debug(\"Calling AWS callback from invoke promise resolve handler\");\n                            this.boundCallback();\n                        }\n\n                        self.logger.debug(\"Resolving with result: %s\", value);\n                        this.rookout.notifyLambdaInactive(this.context);\n                        resolve(value);\n                    });\n                }).catch((err) => {\n                    self.flush(() => {\n                        // The user might have returned a Promise/used an async function *and* called the callback.\n                        if (this.callbackCalled) {\n                            self.logger.debug(\"Calling AWS callback from invoke promise reject handler\");\n                            this.boundCallback();\n                        }\n                        this.rookout.notifyLambdaInactive(this.context);\n                        reject(err);\n                    });\n                });\n            });\n        } else {\n            this.flush();\n\n            return result;\n        }\n    }\n\n    flush(callback) {\n        if (this.rookout) {\n            let flushPromise = new Promise((resolve) => {\n                this.rookout.flush(() => resolve());\n            }).catch(() => {});\n\n            Promise.race([flushPromise, this.timeoutResolver(5000)]).then(() => {\n                if (callback) {\n                    callback()\n                }\n            }).catch(() => {});\n        }\n    }\n\n    timeoutResolver(timeout) {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                resolve();\n            }, timeout).unref();\n        })\n    }\n}\n\nlet invokeAndChain = (wrapper, resolve, reject) => {\n    try {\n        let invoke_result = wrapper.invoke();\n        if (invoke_result !== undefined && invoke_result.then !== undefined) {\n            invoke_result.then((value) => resolve(value))\n                .catch((err) => {\n                    reject(err);\n                })\n        } else {\n            // intentionally empty - we must not resolve the promise so that the lambda only ends after timeout\n            // or when the callback is called\n        }\n    } catch(err) {\n        reject(err);\n    }\n};\n\nexports.wrap = (originalFunction, options = {}) => {\n    if (!process.env.LAMBDA_TASK_ROOT) {\n        return originalFunction;\n    }\n\n    const rook = require('.');\n\n    // An already-resolved Promise\n    let startRook = Promise.resolve();\n    if (!rook.startAttempted) {\n        options.log_file = options.log_file || \"\";\n        options.lambda_safe_start = true;\n        startRook = rook.start(options);\n    }\n\n    return (event, context, callback) => {\n        let wrapper = new RookoutLambdaWrapper(rook, this, originalFunction, event, context, callback);\n        return new Promise((resolve, reject) => {\n            startRook.then(() => invokeAndChain(wrapper, resolve, reject))\n                .catch(() => invokeAndChain(wrapper, resolve, reject));\n        });\n    };\n};\n"],"file":"lambda.js"}